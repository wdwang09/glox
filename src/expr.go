package glox

// This code is generated by a Python script.

type Expr interface {
	Accept(visitor exprVisitor) (interface{}, error)
}

type exprVisitor interface {
	visitAssignExpr(expr *Assign) (interface{}, error)
	visitBinaryExpr(expr *Binary) (interface{}, error)
	visitCallExpr(expr *Call) (interface{}, error)
	visitGetExpr(expr *Get) (interface{}, error)
	visitGroupingExpr(expr *Grouping) (interface{}, error)
	visitLiteralExpr(expr *Literal) (interface{}, error)
	visitLogicalExpr(expr *Logical) (interface{}, error)
	visitSetExpr(expr *Set) (interface{}, error)
	visitSuperExpr(expr *Super) (interface{}, error)
	visitThisExpr(expr *This) (interface{}, error)
	visitUnaryExpr(expr *Unary) (interface{}, error)
	visitVariableExpr(expr *Variable) (interface{}, error)
}

type Assign struct {
	name  *Token
	value Expr
}

func NewAssign(name *Token, value Expr) *Assign {
	expr := new(Assign)
	expr.name = name
	expr.value = value
	return expr
}

func (expr *Assign) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitAssignExpr(expr)
}

type Binary struct {
	left     Expr
	operator *Token
	right    Expr
}

func NewBinary(left Expr, operator *Token, right Expr) *Binary {
	expr := new(Binary)
	expr.left = left
	expr.operator = operator
	expr.right = right
	return expr
}

func (expr *Binary) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitBinaryExpr(expr)
}

type Call struct {
	callee    Expr
	paren     *Token
	arguments *[]Expr
}

func NewCall(callee Expr, paren *Token, arguments *[]Expr) *Call {
	expr := new(Call)
	expr.callee = callee
	expr.paren = paren
	expr.arguments = arguments
	return expr
}

func (expr *Call) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitCallExpr(expr)
}

type Get struct {
	object Expr
	name   *Token
}

func NewGet(object Expr, name *Token) *Get {
	expr := new(Get)
	expr.object = object
	expr.name = name
	return expr
}

func (expr *Get) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitGetExpr(expr)
}

type Grouping struct {
	expression Expr
}

func NewGrouping(expression Expr) *Grouping {
	expr := new(Grouping)
	expr.expression = expression
	return expr
}

func (expr *Grouping) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitGroupingExpr(expr)
}

type Literal struct {
	value interface{}
}

func NewLiteral(value interface{}) *Literal {
	expr := new(Literal)
	expr.value = value
	return expr
}

func (expr *Literal) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitLiteralExpr(expr)
}

type Logical struct {
	left     Expr
	operator *Token
	right    Expr
}

func NewLogical(left Expr, operator *Token, right Expr) *Logical {
	expr := new(Logical)
	expr.left = left
	expr.operator = operator
	expr.right = right
	return expr
}

func (expr *Logical) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitLogicalExpr(expr)
}

type Set struct {
	object Expr
	name   *Token
	value  Expr
}

func NewSet(object Expr, name *Token, value Expr) *Set {
	expr := new(Set)
	expr.object = object
	expr.name = name
	expr.value = value
	return expr
}

func (expr *Set) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitSetExpr(expr)
}

type Super struct {
	keyword *Token
	method  *Token
}

func NewSuper(keyword *Token, method *Token) *Super {
	expr := new(Super)
	expr.keyword = keyword
	expr.method = method
	return expr
}

func (expr *Super) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitSuperExpr(expr)
}

type This struct {
	keyword *Token
}

func NewThis(keyword *Token) *This {
	expr := new(This)
	expr.keyword = keyword
	return expr
}

func (expr *This) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitThisExpr(expr)
}

type Unary struct {
	operator *Token
	right    Expr
}

func NewUnary(operator *Token, right Expr) *Unary {
	expr := new(Unary)
	expr.operator = operator
	expr.right = right
	return expr
}

func (expr *Unary) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitUnaryExpr(expr)
}

type Variable struct {
	name *Token
}

func NewVariable(name *Token) *Variable {
	expr := new(Variable)
	expr.name = name
	return expr
}

func (expr *Variable) Accept(visitor exprVisitor) (interface{}, error) {
	return visitor.visitVariableExpr(expr)
}
