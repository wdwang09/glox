package glox

// This code is generated by a Python script.

type Expr interface {
	Accept(visitor Visitor) interface{}
}

type Visitor interface {
	visitAssignExpr(assign *Assign) interface{}
	visitBinaryExpr(binary *Binary) interface{}
	visitCallExpr(call *Call) interface{}
	visitGetExpr(get *Get) interface{}
	visitGroupingExpr(grouping *Grouping) interface{}
	visitLiteralExpr(literal *Literal) interface{}
	visitLogicalExpr(logical *Logical) interface{}
	visitSetExpr(set *Set) interface{}
	visitSuperExpr(super *Super) interface{}
	visitThisExpr(this *This) interface{}
	visitUnaryExpr(unary *Unary) interface{}
	visitVariableExpr(variable *Variable) interface{}
}

type Assign struct {
	name  *Token
	value Expr
}

func NewAssign(name *Token, value Expr) *Assign {
	assign := new(Assign)
	assign.name = name
	assign.value = value
	return assign
}

func (assign *Assign) Accept(visitor Visitor) interface{} {
	return visitor.visitAssignExpr(assign)
}

type Binary struct {
	left     Expr
	operator *Token
	right    Expr
}

func NewBinary(left Expr, operator *Token, right Expr) *Binary {
	binary := new(Binary)
	binary.left = left
	binary.operator = operator
	binary.right = right
	return binary
}

func (binary *Binary) Accept(visitor Visitor) interface{} {
	return visitor.visitBinaryExpr(binary)
}

type Call struct {
	callee    Expr
	paren     *Token
	arguments []Expr
}

func NewCall(callee Expr, paren *Token, arguments []Expr) *Call {
	call := new(Call)
	call.callee = callee
	call.paren = paren
	call.arguments = arguments
	return call
}

func (call *Call) Accept(visitor Visitor) interface{} {
	return visitor.visitCallExpr(call)
}

type Get struct {
	object Expr
	name   *Token
}

func NewGet(object Expr, name *Token) *Get {
	get := new(Get)
	get.object = object
	get.name = name
	return get
}

func (get *Get) Accept(visitor Visitor) interface{} {
	return visitor.visitGetExpr(get)
}

type Grouping struct {
	expression Expr
}

func NewGrouping(expression Expr) *Grouping {
	grouping := new(Grouping)
	grouping.expression = expression
	return grouping
}

func (grouping *Grouping) Accept(visitor Visitor) interface{} {
	return visitor.visitGroupingExpr(grouping)
}

type Literal struct {
	value interface{}
}

func NewLiteral(value interface{}) *Literal {
	literal := new(Literal)
	literal.value = value
	return literal
}

func (literal *Literal) Accept(visitor Visitor) interface{} {
	return visitor.visitLiteralExpr(literal)
}

type Logical struct {
	left     Expr
	operator *Token
	right    Expr
}

func NewLogical(left Expr, operator *Token, right Expr) *Logical {
	logical := new(Logical)
	logical.left = left
	logical.operator = operator
	logical.right = right
	return logical
}

func (logical *Logical) Accept(visitor Visitor) interface{} {
	return visitor.visitLogicalExpr(logical)
}

type Set struct {
	object Expr
	name   *Token
	value  Expr
}

func NewSet(object Expr, name *Token, value Expr) *Set {
	set := new(Set)
	set.object = object
	set.name = name
	set.value = value
	return set
}

func (set *Set) Accept(visitor Visitor) interface{} {
	return visitor.visitSetExpr(set)
}

type Super struct {
	keyword *Token
	method  *Token
}

func NewSuper(keyword *Token, method *Token) *Super {
	super := new(Super)
	super.keyword = keyword
	super.method = method
	return super
}

func (super *Super) Accept(visitor Visitor) interface{} {
	return visitor.visitSuperExpr(super)
}

type This struct {
	keyword *Token
}

func NewThis(keyword *Token) *This {
	this := new(This)
	this.keyword = keyword
	return this
}

func (this *This) Accept(visitor Visitor) interface{} {
	return visitor.visitThisExpr(this)
}

type Unary struct {
	operator *Token
	right    Expr
}

func NewUnary(operator *Token, right Expr) *Unary {
	unary := new(Unary)
	unary.operator = operator
	unary.right = right
	return unary
}

func (unary *Unary) Accept(visitor Visitor) interface{} {
	return visitor.visitUnaryExpr(unary)
}

type Variable struct {
	name *Token
}

func NewVariable(name *Token) *Variable {
	variable := new(Variable)
	variable.name = name
	return variable
}

func (variable *Variable) Accept(visitor Visitor) interface{} {
	return visitor.visitVariableExpr(variable)
}
